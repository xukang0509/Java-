# 数据结构与算法

## 宏定义

在本笔记中用到的宏定义，头文件为define.h

```c
#define TRUE 1
#define FALSE 0

#define OK 1
#define ERROR 0

#define INFEASIBLE -1
#define OVERFLOW -2  // 溢出

typedef int Status;
```



## 一、线性表

### 1 顺序表(Sequence List)

特点：逻辑上相邻的数据元素，其物理次序也是相邻的

线性表中第 `i+1` 个数据元素的存储位置 LOC(a<sub>i+1</sub>) 和第 `i` 个元素满足下列关系

LOC(a<sub>i+1</sub>) = LOC(a<sub>i</sub>) + l

LOC(a<sub>i</sub>) = LOC(a<sub>1</sub>) + (i-1)*l

l：代表每个元素所占用的空间



#### -顺序表的存储结构

```c
#define SQLMAXSIZE 100
// 顺序表的存储结构
typedef int SqlElemType;
typedef struct SqList {
    SqlElemType *data;    // 数据
    int length;           // 当前线性表的长度
} SqList;
```

#### -初始化

```c
// 初始化
Status InitSql (SqList *L, int length) {
    L->data = (SqlElemType*) malloc(sizeof(SqlElemType) * SQLMAXSIZE);
    if (!L->data) {
        return OVERFLOW;
    }
    L->length = 0;
    for (int i = 1; i <= length; ++i) {
        SqlElemType e;
        scanf("%d", &e);
        SqlInsert(L, i, e);
    }
    return OK;
}
```

#### -获取元素

```c
// 获取元素
Status GetElem(SqList *L, int position, SqlElemType *e) {
    if (!L->data) return ERROR;
    if (position < 1 || position > L->length) return ERROR;
    *e = L->data[position - 1];
    return OK;
}
```

#### -查找元素

```c
// 查找元素
int LocateElem(SqList *L, SqlElemType e) {
    if (!L->data) return OVERFLOW;
    for (int i = 0; i < L->length; ++i) {
        if (L->data[i] == e) return i + 1;
    }
    return 0; // 0代表元素不在顺序表中
}
```

平均查找长度ASL(Average Search Length)
$$
ASL = \sum_{i=1}^{n} p_iC_i
$$
p<sub>i</sub>为查找第i个元素成功的概率

C<sub>i</sub>为查找第i个元素需要比较的次数

可知 p<sub>i</sub> = 1/n

C<sub>i</sub>为第i个元素在表中位置
$$
ASL = \frac{1}{n}\sum_{i=1}^{n}i = \frac{n+1}{2}
$$
因此可知 LocateElem 的时间复杂度为 O(n)

#### -插入元素

```c
// 插入
Status SqlInsert(SqList *L, int position, SqlElemType e) {
    if (!L->data || L->length == SQLMAXSIZE) return ERROR;
    if (position < 1 || position > L->length + 1) return ERROR;
    for (int i = L->length - 1; i >= position - 1; i--) {
        // 注意需要把数组中的元素全部向右移动，需要从数组最右边的元素开始移动
        L->data[i+1] = L->data[i];
    }
    L->data[position - 1] = e;
    L->length++;
    return OK;
}
```

E<sub>ins</sub> 表示插入元素所需要移动元素次数的期望值(平均次数)
$$
E_{ins}=\sum_{i=1}^{n+1}p_i(n-i+1)
$$
假设在各个位置上插入元素的概率相等p<sub>i</sub> = 1/(n+1)
$$
E_{ins}=\frac{1}{n+1}\sum_{i=1}^{n+1}(n-i+1)=\frac{n}{2}
$$
因此可知 SqlInsert 的时间复杂度为 O(n)

#### -删除元素

```c
// 删除
Status SqlDelete(SqList *L, int position, SqlElemType *e) {
    if (!L->data || L->length == 0) return ERROR;
    if (position < 1 || position > L->length) return ERROR;
    *e = L->data[position - 1];
    for (int i = position - 1; i < L->length - 1; i++) {
        L->data[i] = L->data[i+1];
    }
    L->length--;
    return OK;
}
```

$$
E_{del}=\sum_{i=1}^{n}p_i(n-i)=\frac{1}{n}\sum_{i=1}^{n}(n-i)=\frac{n-1}{2}
$$

因此可知 SqlDelete 的时间复杂度为 O(n)

#### -销毁、清空线性表

```c
// 销毁线性表
Status SqlDestroy(SqList *L) {
    if (!L->data) {
        return ERROR;
    }
    free(L->data);
    return OK;
}

// 清空线性表
void SqlClear(SqList *L) {
    L->length = 0;
}
```

#### -检查为空、获取线性表长度

```c
// 判断线性表是否为空
Status SqlIsEmpty(SqList L) {
    return L.length == 0 ? TRUE : FALSE;
}

// 求线性表的长度
int SqlLength(SqList L) {
    return L.length;
}
```

#### -顺序表的头文件

```c
#define SQLMAXSIZE 100

// 顺序表的存储结构
typedef int SqlElemType;
typedef struct SqList {
    SqlElemType *data;    // 数据
    int length;           // 当前线性表的长度
} SqList;

// 初始化
Status InitSql (SqList *L, int length);
// 获取元素
Status GetElem(SqList *L, int position, SqlElemType *e);
// 查找元素
int LocateElem(SqList *L, SqlElemType e);
// 插入
Status SqlInsert(SqList *L, int position, SqlElemType e);
// 删除
Status SqlDelete(SqList *L, int position, SqlElemType *e);
// 销毁线性表
Status SqlDestroy(SqList *L);
// 清空线性表
void SqlClear(SqList *L);
// 判断线性表是否为空
Status SqlIsEmpty(SqList L);
// 求线性表的长度
int SqlLength(SqList L);
```



### 2 单链表(Single Linked List)

- 单链表由头节点(不存放数据只存放下个节点的地址)和n个节点组成，
- 每个节点分为两个域：*数据域*和*指针域(存放下个节点的地址)*
- 第n个节点的指针域为NULL

如下图所示

![image-20230625170356192](./851.assets/image-20230625170356192.png)

#### -单链表的存储结构

```c
typedef int LlElemType;
typedef struct _LNode {
    LlElemType data;      //存放单个节点的数据
    struct _LNode *next;  //存放下个节点的地址
} LNode, *LinkList;
```

#### -初始化

```c
// 初始化
Status InitLL(LinkList *L) { // L是一个二级指针
    (*L) = (LinkList) malloc(sizeof(LNode));
    (*L)->next = NULL;
    return OK;
}
```

#### -创建链表(头插法) O(n)

```c
// 创建链表(头插法) O(n)
void CreateLL_H(LinkList L, int n) {
    //用此方法创建的链表，遍历的顺序和创建的顺序相反
    printf("Please enter %d numbers: \n", n);
    for (int i = 0; i < n; ++i) {
        LinkList p = (LinkList) malloc(sizeof(LNode));
        LlElemType data;
        scanf("%d", &data);
        p->data = data;
        p->next = L->next;
        L->next = p;
    }
}
```

#### -创建链表(尾插法) O(n)

```c
// 创建链表(尾插法) O(n)
void CreateLL_T(LinkList L, int n) {
    LinkList pTail = L;
    printf("Please enter %d numbers: \n", n);
    for (int i = 0; i < n; ++i) {
        LinkList p = (LinkList) malloc(sizeof(LNode));
        LlElemType data;
        scanf("%d", &data);
        p->data = data;
        p->next = NULL;
        pTail->next = p;
        pTail = p;
    }
}
```

#### -获取元素 O(n)

```c
// 获取元素 O(n)
Status GetElem(LinkList L, int pos, LlElemType *e) {
    LinkList p = L->next;               // p 指向 链表L 的第一个结点
    int j = 1;                          // j 为计数器
    while (p && j < pos) {              // p不为空且j计数器还没有等于pos时
        p = p->next;                    // p指向下一个结点
        j++;
    }
    if (!p || j > pos) return ERROR;    // 第 pos 个结点不存在
    *e = p->data;                       // 取第 pos 个结点的数据
    return OK;
}
```

#### -查找元素 O(n)

```c
// 查找元素 O(n) 返回节点
LinkList LocateElem_e (LinkList L, LlElemType e) {
    LinkList p = L->next;
    while (p && p->data != e) {
        p = p->next;
    }
    if (!p) return NULL; //如果 p 的地址为空,说明 e 不在链表中
    return p;
}

// 查找元素 O(n) 返回节点在线性表中的下标位置
int LocateElem_i (LinkList L, LlElemType e) {
    LinkList p = L->next;
    int i = 1;
    while (p && p->data != e) {
        p = p->next;
        i++;
    }
    if (!p) return 0; //如果 p 的地址为空，说明 e 不在链表中，返回0
    return i;
}
```

#### -插入元素 O(n)

<img src="./851.assets/image-20230625171325975.png" alt="image-20230625171325975" align="left" />

想在 a，b 之间插入 x, 需要先知道 a 节点的地址
如图所示，如果想要在位置 i 插入节点，则需要知道位置 i-1 节点的位置

<img src="./851.assets/image-20230625171448532.png" alt="image-20230625171448532" align="left" />

- 注意因为插入操作和GetElem操作不同
- 要从0开始，p要从L开始
- 如果从1和L开始的话，无法在位置1插入元素

```c
// 插入元素 O(n)
Status LlInsert(LinkList L, int pos, LlElemType e) {
    LinkList p = L;                     // 注意因为插入操作和GetElem操作不同
    int i = 0;                          // i要从0开始，p要从L头结点开始
    // 如果从1和L首元结点开始的话，无法在位置1插入元素
    while (p && i < pos-1) {      //查找插入节点位置的前一个节点
        p = p->next;
        i++;
    }
    if (!p || i > pos - 1) return ERROR;

    LinkList newP = (LinkList) malloc(sizeof(LNode));
    newP->data = e;
    newP->next = p->next;
    p->next = newP;
    return OK;
}
```

#### -删除元素 O(n)

<img src="./851.assets/image-20230625171620674.png" alt="image-20230625171620674" align="left" />

想要删除 b，则必须先知道 a 的地址

- 注意因为删除操作和GetElem操作不同
- 要从0开始，p要从L开始
- 如果从1和L开始的话，无法在位置1删除元素

<img src="./851.assets/image-20230625171724146.png" alt="image-20230625171724146" align="left" />

```c
// 删除元素 O(n)
Status LlDelete(LinkList L, int pos, LlElemType *e) {
    LinkList p = L, q;
    int i = 0;
    while (p && i < pos - 1) { // 查找删除节点位置的前一个节点
        p = p->next;
        i++;
    }
    //注意是 多增加了判断条件!(p->next)，当节点数为n，删除的位置为n+1时会返回error
    if (!p || !p->next || i > pos - 1) return ERROR;

    q = p->next;
    *e = q->data;
    p->next = q->next;
    free(q);
    return OK;
}
```

#### -总结插入和删除操作算法的不同

```c
while (p){
	p = p->next;
} //最终p的值为NULL

while(p->next){
	p = p->next;
} //最终p的值为最后一个节点的地址
```

```c
//---------------------插入----------------------
//如果插入操作的pos不合法，即pos > n+1(n为链表长度)，那么p一定会指向NULL，此时按照退出条件!p可以返回ERROR
if (!p || i > pos-1) return ERROR;
//但是如果采用:
while(p->next)
//则最终会指向链表最后一个节点，即使pos不合法，那么也会在最后一个节点后方插入新节点
//所以使用:
while(p)
```

```c
////---------------------删除----------------------
//如果删除操作的pos不合法，即pos>链表长度，p会指向最后一个节点的地址(pos == n+1时)或是NULL(pos > n+1)，那么下面的代码会出错
LinkList pfree = p->next;
//如果p指向最后一个节点，此时pfree指向NULL。如果p指向NULL，此时pfree指向非法空间(不受主程序控制)，从而导致下面代码报错
*e = pfree->data;
//所以需要增加一个判断条件
if (i> pos-1 || !p || !p->next) return ERROR;
// 必须保证 !p 要在 !p->next的左边，即 position > n+1 的情况
// 这是因为如果 !p->next 在 !p 的左边，如果p指向NULL，那么NULL->next会报错
```

#### -销毁链表、清空链表 O(n)

```c
// 销毁链表 O(n)
Status LlDestroy(LinkList L) {
    LinkList p;
    while (L) {
        p = L;
        L = L->next;
        free(p);
    }
    return OK;
}

// 清空链表 O(n)
Status LlClear(LinkList L) {
    LinkList p = L->next, q;    // p指向第一个结点
    while (p) {                 // 没到表尾
        q = p;
        p = p->next;
        free(q);
    }
    L->next = NULL;             // 头结点指针域置位空
    return OK;
}
```

#### -求单链表的长度 O(n)

```c
// 求单链表的长度 O(n)
int LlLength(LinkList L) {
    LinkList p = L->next;
    int i = 0;
    while (p) {
        p = p->next;
        ++i;
    }
    return i;
}
```

#### -单链表头文件

```c
typedef int LlElemType;
typedef struct _LNode {
    LlElemType data;      //存放单个节点的数据
    struct _LNode *next; //存放下个节点的地址
} LNode, *LinkList;

// 初始化
Status InitLL(LinkList *L);
// 创建链表(头插法) O(n)
void CreateLL_H(LinkList L, int n);
// 创建链表(尾插法) O(n)
void CreateLL_T(LinkList L, int n);
// 获取元素 O(n)
Status GetElem(LinkList L, int pos, LlElemType *e);
// 查找元素 O(n)
LinkList LocateElem_e (LinkList L, LlElemType e);
int LocateElem_i (LinkList L, LlElemType e);
// 插入元素 O(n)
Status LlInsert(LinkList L, int pos, LlElemType e);
// 删除元素 O(n)
Status LlDelete(LinkList L, int pos, LlElemType *e);
// 销毁链表 O(n)
Status LlDestroy(LinkList L);
// 清空链表 O(n)
Status LlClear(LinkList L);
// 求单链表的长度 O(n)
int LlLength(LinkList L);
```



### 3 循环链表(Circular Linked List)

循环链表的特点：

- 最后一个节点的指针域指向头节点，整个表链形成一个环
- 由此，从表中任意节点出发，可以找到其他节点

![image-20230704161355662](./851.assets/image-20230704161355662.png)

和单链表很像，区别就是最后一个节点的next域指向头节点

1. 单链表中，空表判断`L->next!=NULL`；
2. 循环链表中，空表判断`L->next!=L`；
3. 单链表中，遍历链表时，判别当前指针`p`是否指向表尾节点的终止条件为`p!=NULL`或者`p->next!=NULL`；
4. 而循环链表中，遍历链表时，判别当前指针`p`是否指向表尾节点的终止条件为`p!=L`或者`p->next!=L`；



### 4 双向链表(Double Linked List)

有两个指针域，一个指向直接前驱，另一个指向直接后继

![image-20230704162400849](./851.assets/image-20230704162400849.png)

#### -数据类型

```c
typedef int ElemType;
typedef struct _DouLinkedList {
    ElemType data;
    struct _DouLinkedList * prior;
    struct _DouLinkedList * next;
} DouLinkedNode, *DouLinkedList;
```

#### -初始化

```c
// 初始化
void InitDL (DouLinkedList *L) {
    (*L) = (DouLinkedNode *) malloc(sizeof(DouLinkedNode));
    (*L)->next = NULL;
    (*L)->prior = NULL;
}
```

#### -创建双向链表

```c
// 创建双向链表---头插法
void CreatDL_H (DouLinkedList L, int length) {
    for (int i = 0; i < length; ++i) {
        DouLinkedList newp = (DouLinkedNode *) malloc(sizeof(DouLinkedNode));
        ElemType data;
        printf("(for %d)Please input the data:", i + 1);
        scanf("%d", &data);
        newp->data = data;
        newp->next = L->next;
        if(L->next) L->next->prior = newp;
        newp->prior = L;
        L->next = newp;
    }
}

// 创建双向链表---尾插法
void CreatDL_R (DouLinkedList L, int length) {
    DouLinkedList ptail = L;
    for (int i = 0; i < length; ++i) {
        DouLinkedList pnew = (DouLinkedNode *) malloc(sizeof(DouLinkedNode));
        ElemType data;
        printf("(for %d)Please input the data:", i + 1);
        scanf("%d", &data);
        pnew->data = data;
        pnew->next = NULL;
        pnew->prior = ptail;
        ptail->next = pnew;
        ptail = pnew;
    }
}
```

#### -插入和删除

![image-20230704164431980](./851.assets/image-20230704164431980.png)

```c
// 插入
Status DLInsert(DouLinkedList L, int pos, ElemType e) {
    DouLinkedList p = L;
    int i = 0;
    while (p && i < pos - 1) {
        p = p->next;
        i++;
    }
    if (!p || i > pos - 1) return ERROR;

    DouLinkedList newP = (DouLinkedList) malloc(sizeof(DouLinkedNode));
    newP->data = e;
    newP->next = p->next;					// 1
    newP->prior = p;						// 2    
    if (p->next) p->next->prior = newP;		  // 3
    p->next = newP;							// 4
    return OK;
}

// 删除
Status DLDelete(DouLinkedList L, int pos, ElemType *e){
    DouLinkedList p = L;
    int i = 0;
    while (p && i < pos) { // 找到要删除的节点
        p = p->next;
        i++;
    }
    if (!p || i > pos) return ERROR;

    *e = p->data;
    p->prior->next = p->next;		// 1
    p->next->prior = p->prior;		// 2
    free(p);
    return OK;
}
```



### 5 线性表的应用

#### -线性表合并

已知两个集合：A = { 7, 5, 3, 11 }; B = { 2, 6, 3 };

求出合并之后的集合 A = { 7, 5, 3, 11, 2, 6 };

算法步骤：

1. 分别获取 LA 表长 m 和 LB 表长 n。
2. 从 LB 中第 1 个数据元素开始，循环n次执行以下操作：
   - 从 LB 中查找第i(1<=i<=n)个数据元素赋给e;
   - 在 LA 中查找元素 e, 如果不存在，则将 e 插在表 LA 的最后。

```c
void MergeList(SqList *LA, SqList *LB) {
    int m = LA->length;
    int n = LB->length;
    SqlElemType e;
    for (int i = 1; i <= n; ++i) {
        GetElem(LB, i, &e);
        if (!LocateElem(LA, e)) {
            SqlInsert(LA, ++m, e);
        }
    }
}
```

```c
int main() {
    SqList La, Lb;
    SqList *pa = &La;
    SqList *pb = &Lb;
    InitSql(pa, 4);
    InitSql(pb, 3);

    SqlPrint(La);
    SqlPrint(Lb);

    MergeList(pa, pb);
    SqlPrint(La);
    SqlPrint(Lb);

    return 0;
}
```



#### -有序表合并(并归排序的基础)

有序集合是指集合中的元素有序排列。已知两个有序集合A和B, 数据元素按值非递减有序排列，现要求一个新的集合C=AUB, 使集合C中的数据元素仍按值非递减有序排列。

例如：A = { 3, 5, 8, 11 }; B = { 2, 6, 8, 9, 11, 15, 20 };

C = { 2, 3, 5, 6, 8, 8, 9, 11, 11, 15, 20 };

算法步骤：

1. LA的表长为 m，LB的表长为n，创建一个表长为 m+n 的空表LC；
2. 指针pc初始化，指向LC的第一个元素；
3. 指针pa和pb初始化，分别指向LA和LB的第一个元素；
4. 当指针 pa 和 pb 均未到达相应表尾时，则依次比较pa和pb所指向的元素值，从LA或LB中“摘取”元素值较小的结点插入到LC的最后；
5. 如果pb巳到达LB的表尾，依次将LA的剩余元素插入LC的最后；
6. 如果pa已到达LA的表尾，依次将LB的剩余元素插入LC的最后。

```c
// 已知顺序有序表LA和LB的元素按值非递减排列
// 归并LA和LB得到新的顺序有序表LC, LC的元素也按值非递减排列
void MergeList_Seq(SqList LA, SqList LB, SqList *LC) {
    // 新表长度为待合并两表的长度之和
    LC->length = LA.length + LB.length;
    // 为合并后的新表分配一个数组空间
    LC->data = (SqlElemType *) malloc(sizeof(SqlElemType) * LC->length);
    // 指针 pc 指向新表的第一个元素
    SqlElemType *pc = LC->data;
    // 指针 pa 和 pb 的初值分别指向两个表的第一个元素
    // 指针 pa_last 指向 LA 的最后一个元素
    // 指针 pb_last 指向 LB的最后一个元素
    SqlElemType *pa = LA.data, *pa_last = LA.data + LA.length - 1;
    SqlElemType *pb = LB.data, *pb_last = LB.data + LB.length - 1;
    // LA和LB均未到达表尾
    while ((pa <= pa_last) && (pb <= pb_last)) {
        // 依次"摘取"两表中值较小的结点插人到LC的最后
        if (*pa <= *pb) *pc++ = *pa++;
        else *pc++ = *pb++;
    }
    // LB已到达表尾，依次将LA的剩余元素插人LC的最后
    while (pa <= pa_last) { *pc++ = *pa++; }
    // LA已到达表尾，依次将LB的剩余元素插人LC的最后
    while (pb <= pb_last) { *pc++ = *pb++; }
}
```



#### -有序链表合并

1. 指针 pa 和 pb 初始化，分别指向LA和LB的第一个结点；
2. LC 的结点取值为 LA 的头结点；
3. 指针 pc 初始化，指向LC的头结点；
4. 当指针 pa 和 pb 均未到达相应表尾时，则依次比较 pa 和 pb 所指向的元素值，从 LA 或 LB 中“摘取”元素值较小的结点插入到 LC 的最后；
5. 将非空表的剩余段插入到 pc 所指结点之后；
6. 释放 LB 的头结点。

```c
void MergeList_L(LinkList LA, LinkList LB, LinkList *LC) {
    *LC = LA;
    LinkList pa = LA->next, pb = LB->next;
    LinkList pc = *LC;
    while (pa && pb) {
        if (pa->data <= pb->data) {
            pc->next = pa;
            pc = pa;
            pa = pa->next;
        } else {
            pc->next = pb;
            pc = pb;
            pb = pb->next;
        }
    }
    pc->next = pa ? pa : pb;
    free(LB);
}
```



## 二、栈和队列(Stack and Queue)

### 1 顺序栈(Sequence Stack)

栈是限定仅在*表尾*进行*插入或删除操作*的线性表，表末端为栈顶(Top)，表头称为栈顶(Bottom)，不含元素称为空栈(用顺序表存储的栈更常见)

因此栈又称为**后进先出(Last in First out, LIFO)**的线性表，如下图

<img src="./851.assets/image-20230705215207900.png" alt="image-20230705215207900" style="zoom: 67%;"  align="left"/>

#### -栈的类型定义

```c
#define MAXSTACK 100
typedef char StackElemType;
typedef struct _SqStack {   // 顺序栈，最常用
    StackElemType * base;   // 栈底指针
    StackElemType * top;    // 栈顶指针
    int stackSize;          // 栈可用的最大容量
} SqStack;
```

#### -栈的初始化

1. 为顺序栈动态分配一个最大容最为 MAXSIZE 的数组空间，使 base 指向这段空间的基地址，即栈底。
2. 栈顶指针 top 初始为 base, 表示栈为空。
3. stacksize 置为栈的最大容量 MAXSTACK

```c
// 初始化栈
Status InitStack(SqStack *S) {
    S->base = (StackElemType *) malloc(sizeof(StackElemType) * MAXSTACK);
    if (!S->base) exit(OVERFLOW);
    S->top = S->base;			// 栈顶指向栈底，表示栈空
    S->stackSize = MAXSTACK;     // stackSize 置为栈的最大容量 MAXSTACK
    return OK;
}
```

<img src="./851.assets/image-20230705215449261.png" alt="image-20230705215449261" style="zoom:80%;" />

观察上图，发现top指向内存空间不存放元素

#### -入栈

因为top指向的内存不存放空间，当为base分配的空间存满元素时，`top=分配空间的最后一个元素的地址+1`，此时表示栈满，即`top-base = stackSize`。

1. 判断栈是否满，若满则返回ERROR；
2. 将新元素压入栈顶，栈顶指针加1。

```c
// 入栈
Status Push(SqStack *S, StackElemType e) {
    // 栈满
    if (S->top - S->base == S->stackSize) return ERROR;
    // top指向内存单元存放e，且top指向下一个内存单元
    *S->top++ = e;
    return OK;
}
```

#### -出栈

当`base == top`时，表示栈空

1. 判断栈是否空，若空则返回ERROR。
2. 栈顶指针减1, 栈顶元素出栈。

```c
// 出栈
Status Pop(SqStack *S, StackElemType *e) {
    // 栈空
    if (S->top == S->base) return ERROR;
    *e = *--S->top;
    return OK;
}
```

#### -栈的其他操作

```c
// 获取栈顶元素
Status GetTop(SqStack *S, StackElemType *e) {
    if (S->top == S->base) return ERROR;
    *e = *(S->top - 1);
    return OK;
}

// 判断栈是否为空；若栈为空返回TRUE，否则返回FALSE
Status IsEmpty(SqStack *S) {
    return S->top == S->base ? TRUE : FALSE;
}

// 判断栈是否已满；若栈已满返回TRUE，否则返回FALSE
Status IsFull(SqStack *S) {
    return S->top - S->base == S->stackSize ? TRUE : FALSE;
}
```



### 2 链栈(Linked Stack)

由于栈的主要操作是对栈顶进行Push和Pop，所以选用top作为链表的头节点

#### -链栈的类型定义

```c
typedef char SElemType;
typedef struct _StackNode { // 链栈
    SElemType data;
    struct _StackNode *next;
} StackNode, *LinkStack;
```

#### -链栈_初始化

链栈的初始化操作就是构造一个空栈，因为没必要设头结点，所以直接将栈顶指针置空即可。

```c
// 链栈初始化
// 构造一个空栈S, 栈顶指针置空
Status InitStack (LinkStack *S) {
    *S = NULL;
    // (*S)->next = NULL; 不需要此行代码
    return OK;
}
```

#### -链栈_入栈

`在第一次Push时，第一个节点的next指向NULL`。

1. 为入栈元素e分配空间，用指针p指向。
2. 将新结点数据域置为e。
3. 将新结点插入栈顶。
4. 修改栈顶指针为p。

<img src="./851.assets/image-20230705223247868.png"  alt="image-20230705223247868" style="zoom:80%;"  align="left"/>

```c
// 链栈-入栈
Status Push(LinkStack *S, SElemType e) {
    LinkStack p = (LinkStack) malloc(sizeof(StackNode));
    p->data = e;
    p->next = *S; 	// 将新结点插人栈顶
    *S = p;         // 修改栈顶指针为p
    return OK;
}
```

#### -链栈_出栈

<img src="./851.assets/image-20230705223416921.png" alt="image-20230705223416921"  align="left"/>

1. 判断栈是否为空，若空则返回ERROR。
2. 将栈顶元素赋给e。
3. 临时保存栈顶元素的空间，以备释放。
4. 修改栈顶指针，指向新的栈顶元素。
5. 释放原栈顶元素的空间。

```c
// 链栈-出栈
Status Pop(LinkStack *S, SElemType *e) {
    if ((*S) == NULL) return ERROR; // 栈空
    *e = (*S)->data;
    LinkStack pFree = *S;
    *S = (*S)->next;
    free(pFree);
    return OK;
}
```

#### -链栈的其他操作

```c
// 链栈-获取栈顶元素
Status GetTop(LinkStack S, SElemType *e) {
    if (!S) return ERROR;
    *e = S->data;
    return OK;
}

// 链栈-判断栈是否为空
Status IsEmpty(LinkStack S) {
    return !S ? TRUE : FALSE;
}
```



### 3 栈与递归

#### -函数的调用过程

调用前，系统完成：

1. 将实参，返回地址(下行代码地址)等传递给被调用函数
2. 为被调用函数的局部变量分配空间
3. 将控制转移到被调用函数的入口

调用后，系统完成：

1. 保存被调用函数的计算结果(返回值)
2. 释放被调用函数的数据区
3. 依照被调用函数保存的返回地址，将控制转移到调用函数



```c
long fact(long n) {
    if(n==0) return 1;
    return n * fact(n-1);
}
```

递归调用函数时，如下图

<img src="./851.assets/image-20230705224341766.png" alt="image-20230705224341766" style="zoom:67%;"  align="left"/>

- 按照调用顺序依此把各个函数入栈
- 当栈顶函数满足return条件时，依此出栈(按照FISLO原则)，并且返回值从上向下传递
- 直到主程序调用的fact(4)出栈后，递归完成



### 4 循环队列

定义：只能在*表的一端进行插入运算*，*在表的另一端进行删除*运算的线性表；

**先进先出(First in First out)**原则



#### -数据类型定义

```c
#define QMAXSIZE 100
typedef char QElemType;
typedef struct _SqQueue {
    QElemType * base;
    int front, rear; // front为队头下标，rear为队尾下标 (rear下标的位置不存放元素)
} SqQueue;
// 入队rear+1, 出队front+1,但是此种情况存在问题，如下图
```

<img src="./851.assets/image-20230709144248269.png" alt="image-20230709144248269" style="zoom:67%;" align="left" />

如上图，(d)虽然数组中的空间没有满，但是rear却不能继续增加，假溢出
解决方法：把base数组想象成一个环形的循环队列如下图

<img src="./851.assets/image-20230709144327909.png" alt="image-20230709144327909" style="zoom:80%;" align="left" />

<img src="./851.assets/image-20230709145005817.png" alt="image-20230709145005817" align="left" />

此时如果`front == rere`表示**队空**，而`front == (rere+1) % QMAXSIZE`时表示**队满**。

#### -循环队列初始化

```c
// 循环队列初始化
Status InitQueue(SqQueue *Q) {
    Q->base = (QElemType *) malloc(sizeof(QElemType) * QMAXSIZE);
    if (!Q->base) exit(OVERFLOW);
    Q->front = 0;
    Q->rear = 0;
    return OK;
}
```

#### -循环队列入队

1. 判断队列是否满，若满则返回ERROR。
2. 将新元素插入队尾。
3. 队尾指针加 1。

```c
// 循环队列入队
Status EnQueue(SqQueue *Q, QElemType e) {
    if (Q->front == (Q->rear + 1) % QMAXSIZE) return ERROR; // 队满
    Q->base[Q->rear] = e;
    Q->rear = (Q->rear + 1) % QMAXSIZE; // Q->rear++; 为错误写法
    return OK;
}
```

#### -循环队列出队

1. 判断队列是否为空，若空则返回ERROR。
2. 保存队头元素。
3. 队头指针加1。

```c
// 循环队列出队
Status DeQueue(SqQueue *Q, QElemType *e) {
    if (Q->front == Q->rear) return ERROR; // 队空
    *e = Q->base[Q->front];
    Q->front = (Q->front + 1) % QMAXSIZE;  // Q->front++; 为错误写法
    return OK;
}
```

#### -循环队列其他操作

```c
// 判断队列是否为空，若队列为空，返回TRUE，否则返回FALSE
Status IsEmpty(SqQueue *Q) {
    if (Q->front == Q->rear)
        return TRUE;
    else
        return FALSE;
    // OR
    // return Q->front == Q->rear;
}

// 判断队列是否已满
Status IsFull(SqQueue *Q) {
    if(Q->front == (Q->rear + 1) % QMAXSIZE)
        return TRUE;
    else
        return FALSE;
    // OR
    // return Q->front == (Q->rear + 1) % QMAXSIZE;
}

// 获取循环队列的队头元素
Status GetHead(SqQueue *Q, QElemType *e) {
    if (Q->front == Q->rear) return ERROR; // 队空
    *e = Q->base[Q->front];
    return OK;
}

// 获取循环队列的元素个数
int LengthQueue(SqQueue *Q) {
    return (Q->rear - Q->front + QMAXSIZE) % QMAXSIZE;
}
```



### 5 链队

链队结构类似于链表，不同于链表的头指针，用两个指针域 `front`、`rear` 来表示队列，如下图

<img src="./851.assets/image-20230709145337940.png" alt="image-20230709145337940" style="zoom:80%;" align="left" />

#### -数据类型定义

```c
typedef char QElemType;
typedef struct _QNode {
    QElemType data;
    struct _QNode *next;
} QNode, *QueuePtr;
typedef struct {
    QueuePtr front;  // front相当于链表的头指针
    QueuePtr rear;   // rear指向整个链表的最后一个节点
} LinkQueue;
```

#### -链队初始化

```c
// 链队初始化
Status InitQueue(LinkQueue *Q) {
    // 生成新节点作为头结点，队头队尾指针指向头结点
    Q->front = Q->rear = (QNode *) malloc(sizeof(QNode));
    if (!Q->front) exit(OVERFLOW);
    Q->front->next = NULL; // 头结点的指针域置位空
    return OK;
}
```

#### -链队入队

<img src="./851.assets/image-20230709153743945.png" alt="image-20230709153743945" style="zoom:67%;"  align="left"/>

```c
// 链队入队 头删尾插
Status EnQueue(LinkQueue *Q, QElemType e) {
    // 为入队元素分配结点空间
    QueuePtr newP = (QueuePtr) malloc(sizeof(QNode));
    if(!newP) exit(OVERFLOW);
    newP->data = e;         // 将新结点的数据域置为e
    newP->next = NULL;      // 将新结点的指针域置为空
    Q->rear->next = newP;   // 将新结点插入到队尾
    Q->rear = newP;         // 修改队尾指针
    return OK;
}
```

#### -链队出队

```c
// 链队出队 头删尾插
Status DeQueue(LinkQueue *Q, QElemType *e) {
    if (Q->front == Q->rear) return ERROR;    // 队空
    QueuePtr p = Q->front->next;              // p指向队头元素
    *e = p->data;                             // e保存队头元素的值
    Q->front->next = p->next;                 // 修改头结点的指针域
    // 如果删除的节点为队尾，那么释放p之后，rear指向未知存储空间
    if (p == Q->rear) Q->rear = Q->front;
    free(p);                          // 释放原队头元素的空间
    return OK;
}
```

#### -链队的其他操作

```c
// 取链队的队头元素
Status GetHead(LinkQueue *Q, QElemType *e) {
    if (Q->front == Q->rear) return ERROR; // 队空
    *e = Q->front->next->data;
    return OK;
}

// 判断链队是否为空
Status IsEmpty(LinkQueue *Q) {
    return Q->front == Q->rear;
}

// 获取链队的元素个数
int LengthQueue(LinkQueue *Q) {
    QueuePtr p = Q->front->next;
    int count = 0;
    while (p) {
        p = p->next;
        count++;
    }
    return count;
}
```



### 6 栈与队列的应用

#### -进制转化

一个进制转换函数，有一个参数n(十进制)，要求输出n的8进制

```c
//注：typedef int StackElemType;
void Convert10To8 (int n) {
    SqStack S;
    InitStack(&S);
    int temp = n;
    while(temp) {
        Push(&S, temp%8);
        temp = temp/8;
    }
    int e;
    while(!IsEmpty(&S)) {
        Pop(&S, &e);
        printf("%d", e);
    }
    printf("\n");
}
```

一个进制转换函数，有一个参数n(十进制)，要求输出n的16进制

```c
//注：typedef int StackElemType;
void Convert10To16(int n) {
    SqStack S;
    InitStack(&S);
    int temp = n;
    while (temp) {
        Push(&S, temp % 16);
        temp = temp / 16;
    }
    int e;
    while (!IsEmpty(&S)) {
        Pop(&S, &e);
        if (e < 10)
            printf("%d", e);
        else {
            printf("%c", e - 10 + 'A');
        }
    }
    printf("\n");
}
```



#### -括号的匹配

传入字符串括号`()[]{}`，判断括号是否匹配成功，`\0`字符表示输入结束

例：`([({})])` 成功 `[(()){}]]` 失败

```c
Status Matching_Parentheses(char *str) {
    SqStack *S = NULL;
    InitStack(&S);
    char *ch, pop;
    Status flag = TRUE;
    for (ch = str; *ch != '\0'; ch++) {
        switch (*ch) {
            case '(':
            case '[':
            case '{':
                Push(S, *ch);
                break;
            case ')':
                if(!IsEmpty(S)) {
                    Pop(S, &pop);
                    if (pop != '(') flag = FALSE;
                } else flag = FALSE;
                break;
            case ']':
                if(!IsEmpty(S)) {
                    Pop(S, &pop);
                    if (pop != '[') flag = FALSE;
                } else flag = FALSE;
                break;
            case '}':
                if(!IsEmpty(S)) {
                    Pop(S, &pop);
                    if (pop != '{') flag = FALSE;
                } else flag = FALSE;
                break;
        }
    }
    if (flag && IsEmpty(S)) {
        return TRUE;
    }
    return FALSE;
    // OR return (flag && IsEmpty(S));
}
```



## 三、字符串、数组和广义表



## 四、树和二叉树

### 1 树的定义

树(Tree)是n(n>=0)个节点的有限集合，当n==0时为空树；对于非空树T，有：

1. 有且只有一个称之为根的节点
2. 除根节点外，可分为m(m>0)个互不相交的有限集，T1、T2、...、Tm，其中一个集合本身又是一棵树，称之为根的子树(SubTree)。

<img src="./851.assets/image-20230709165355225.png" alt="image-20230709165355225" style="zoom:50%;"  align="left"/>

### 2 树的基本术语

**节点、根节点、父节点、子节点、兄弟节点**；

- 一棵树可以没有任何节点，称为**空树**
- 一棵树可以只有 1 个节点，也就是只有根节点



**节点的度（degree）**：节点拥有的子树个数成为节点的度；如上图中degree(A) = 3, degree(C) = 1, degree(F) = 0

**树的度**：所有节点中度的最大值；上图的度为3

**叶子节点（leaf）**：度为 0 的节点；

**非叶子节点**：度不为 0 的节点；



**层数（level）**：根节点在第 1 层，根节点的子节点在第 2 层，以此类推（有些教程也从第 0 层开始计算）

**节点的深度（depth）**：从根节点到当前节点的唯一路径上的节点总数；

**节点的高度（height）**：从当前节点到最远叶子节点的路径上的节点总数；



**树的深度**：所有节点深度中的最大值；

**树的高度**：所有节点高度中的最大值；

**树的深度** 等于 **树的高度**；



**有序树**、**无序树**、**森林**

**有序树**：树中任意节点的子节点之间有顺序关系；

**无序树**：树中任意节点的子节点之间没有顺序关系，也称为 “自由树”；

**森林**：由 m（m ≥ 0）棵互不相交的树组成的集合；对任意一棵树而言，其子树组成森林



### 3 二叉树的定义及性质

二叉树的定义：

**二叉树**(Binary Tree) 是 n(n>=0) 个节点所构成的集合，n==0时为空树；对于非空树T：

1. 有且仅有一个称之为根的节点
2. 除根节点外，有互不相交的子集T1和T2，分别称为T的左子树和右子树，且T1和T2本身又都是二叉树。



二叉树的性质：

1. 每个节点最多有两颗子树(即二叉树中不存在度大于2的节点)
2. 二叉树的子树有左右之分，其次序不能任意颠倒。



### 4 二叉树定理

定理1：在二叉树的第i层上，最多有2<sup>i-1</sup>个节点

定理2：深度为k的二叉树，最多有2<sup>k</sup>-1个节点

Proof：2<sup>0</sup> + 2<sup>1</sup> + 2<sup>2</sup> + ... + 2<sup>k-1</sup> = 1*(1-2<sup>k</sup>)/(1-2) = 2<sup>k</sup>-1



定理3：n<sub>0</sub> = n<sub>2</sub> + 1

Proof：

令一颗二叉树T有n个节点，其中 n<sub>1</sub>，n<sub>2</sub>，n<sub>0</sub> 分别为 度为 1,2,0 的节点个数，即有：

n<sub>1</sub> + n<sub>2</sub> + n<sub>0</sub> = n     (1)

可知T的根无双亲节点，而其它节点都有双亲，令这些有双亲的节点的个数为B，即 B = n - 1 = 0·n<sub>0</sub> + 1·n<sub>1</sub> + 2·n<sub>2</sub> = 1·n<sub>1</sub> + 2·n<sub>2</sub>，即：

1·n<sub>1</sub> + 2·n<sub>2</sub> + 1 = n  (2)

(1)(2)联立得：n<sub>0</sub> = n<sub>2</sub> + 1



### 5 完全二叉树性质及定理

完全二叉树的定义：

















































